
Project-3
You will design a New York City Route Planner where ~20-30 major cities in New York State
(e.g., Rochester, Buffalo, Syracuse, Albany, Ithaca, Binghamton, Niagara Falls, New York City,
etc.) are represented as nodes in a graph. The edges between cities will be weighted by actual
road distances (miles). The heuristic cost for informed search will be the straight-line distance
between city coordinates (compute using the Haversine formula or any other alternatives). The
start node is Rochester (RIT), and the user will choose the destination city. You should
implement DFS, BFS, IDS, UCS, Greedy Best-First Search, A*, and IDA* search to find paths
from Rochester to the chosen destination. For each algorithm, compare the path cost, number
of expanded nodes, and runtime, and clearly identify which algorithm(s) return optimal solutions
under these conditions. A graph drawing with nodes and weighted edges must be developed.
You are required to prepare the dataset yourself (nodes, road distances, and heuristic values),
making any reasonable assumptions whenever needed or when exact data is not obvious




# NYC Route Planner - Project Structure & Implementation Plan

## Project Directory Structure

```
CSCI-{331}-{04}-Group-{6}/
│
├── README.md                    # Project overview, abstract, team members, run instructions
├── requirements.txt             # Python dependencies
├── .gitignore                  # Git ignore file
│
├── code/
│   ├── main.py                 # Main entry point for the application
│   ├── config.py               # Configuration settings (constants, parameters)
│   │
│   ├── core/
│   │   ├── __init__.py
│   │   ├── graph.py            # Graph and City classes
│   │   ├── search_result.py    # SearchResult class
│   │   └── priority_queue.py   # Priority queue implementation
│   │
│   ├── algorithms/
│   │   ├── __init__.py
│   │   ├── base_algorithm.py   # Abstract SearchAlgorithm class
│   │   ├── uninformed/
│   │   │   ├── __init__.py
│   │   │   ├── dfs.py         # Depth-First Search
│   │   │   ├── bfs.py         # Breadth-First Search
│   │   │   ├── ids.py         # Iterative Deepening Search
│   │   │   └── ucs.py         # Uniform Cost Search
│   │   └── informed/
│   │       ├── __init__.py
│   │       ├── greedy.py      # Greedy Best-First Search
│   │       ├── astar.py       # A* Search
│   │       └── idastar.py     # IDA* Search
│   │
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── data_loader.py     # Load cities and edges data
│   │   ├── heuristics.py      # Heuristic calculations (Haversine, etc.)
│   │   ├── visualizer.py      # Graph visualization and plotting
│   │   └── route_planner.py   # Main controller class
│   │
│   ├── gui/
│   │   ├── __init__.py
│   │   └── app.py             # Optional GUI interface (Tkinter/Streamlit)
│   │
│   └── tests/
│       ├── __init__.py
│       ├── test_graph.py
│       ├── test_algorithms.py
│       └── test_heuristics.py
│
├── data/
│   ├── cities.csv              # City data (name, latitude, longitude)
│   ├── edges.csv               # Edge data (city1, city2, distance)
│   ├── processed/
│   │   └── graph.pickle        # Cached graph object
│   └── raw/
│       └── ny_cities_data.txt  # Original research data
│
├── resources/
│   ├── papers/                 # Research papers on search algorithms
│   │   ├── astar_paper.pdf
│   │   └── search_algorithms_comparison.pdf
│   ├── references.md           # List of references and resources
│   ├── notes/
│   │   └── algorithm_notes.md
│   └── presentation/
│       └── final_presentation.pptx
│
└── results/
    ├── visualizations/         # Generated graphs and maps
    ├── comparisons/           # Algorithm comparison charts
    └── reports/              # Performance analysis reports

```

## Deliverables Checklist
- [ ] Functional graph with 20-30 NY cities
- [ ] All 7 search algorithms implemented
- [ ] Visual graph representation
- [ ] Performance comparison analysis
- [ ] Optimal algorithm identification
- [ ] Complete documentation
- [ ] Presentation materials
- [ ] Clean, well-commented code
- [ ] Comprehensive README











class GraphVisualizer:
    """Handles graph visualization using matplotlib and networkx"""

    def __init__(self, graph: Graph):
        self.graph = graph
        self.G = self._create_networkx_graph()
        self.pos = None
        self.figure = None
        self.ax = None
        self._setup_positions()



            def load_data(self):
        """Load graph data and initialize components"""
        try:
            # Load graph

            here = Path(__file__).resolve()
            project_root = None
            for up in [here, *here.parents]:
                if (up / "data" / "cities.csv").exists() and (up / "data" / "edges.csv").exists():
                    project_root = up
                    break
            if project_root is None:
                # fallback if the GUI sits under code/gui/
                project_root = here.parent.parent

            cities_csv = project_root / "data" / "cities.csv"
            edges_csv = project_root / "data" / "edges.csv"
            self.graph = load_graph(cities_csv, edges_csv)

            # Correct module and keep it resilient if you run files flat
            try:
                from code.utilities.route_planner import RoutePlanner
            except Exception:
                from code.utilities.route_planner import RoutePlanner
            self.route_planner = RoutePlanner(self.graph)

            # Initialize visualizer
            self.visualizer = GraphVisualizer(self.graph, self.graph_figure)

            # Populate city combos
            cities = sorted(self.graph.get_all_cities())

            self.start_combo.addItems(cities)
            self.goal_combo.addItems(cities)
            self.comp_start_combo.addItems(cities)
            self.comp_goal_combo.addItems(cities)

            # Set default selections
            if "Albany" in cities:
                self.start_combo.setCurrentText("Albany")
                self.comp_start_combo.setCurrentText("Albany")
            if "Buffalo" in cities:
                self.goal_combo.setCurrentText("Buffalo")
                self.comp_goal_combo.setCurrentText("Buffalo")

            # Update statistics
            self.update_statistics()

            # Update city list
            for city in cities:
                connections = len(self.graph.get_neighbors(city))

                self.city_list.addItem(f"{city} ({connections} connections)")

            # Initial graph draw
            self.refresh_graph()

            self.statusBar.showMessage("Data loaded successfully")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load data: {str(e)}")
            self.statusBar.showMessage("Failed to load data")